# 算法与数据结构(十四)：动态规划算法（导弹拦截问题）（C++实现）

#### 动态规划法基本思想

动态规划算法通常用于求解具有某种最优性质的问题。在这类问题中，可能会有许多可行解。每一个解都对应于一个值，我们希望找到具有[最优值](https://baike.baidu.com/item/最优值)的解。动态规划算法与[分治法](https://baike.baidu.com/item/分治法)类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从[这些子](https://baike.baidu.com/item/这些子)问题的解得到原问题的解。与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次。如果我们能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，这样就可以避免大量的重复计算，节省时间。我们可以用一个表来记录所有已解的子问题的答案。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。这就是动态规划法的基本思路。具体的动态规划算法多种多样，但它们具有相同的填表格式。

#### 动态规划法适用条件

1.[最优化原理](https://baike.baidu.com/item/最优化原理)（最优子结构性质） 最优化原理可这样阐述：一个最优化策略具有这样的性质，不论过去状态和决策如何，对前面的决策所形成的状态而言，余下的诸决策必须构成最优策略。简而言之，一个最优化策略的子策略总是最优的。一个问题满足最优化原理又称其具有最优子结构性质。

2.[无后效性](https://baike.baidu.com/item/无后效性)将各阶段按照一定的次序排列好之后，对于某个给定的阶段状态，它以前各阶段的状态无法直接影响它未来的决策，而只能通过当前的这个状态。换句话说，每个状态都是过去历史的一个完整总结。这就是无后向性，又称为无后效性。

3.子问题的重叠性 动态规划将原来具有指数级时间复杂度的[搜索算法](https://baike.baidu.com/item/搜索算法)改进成了具有多项式时间复杂度的算法。其中的关键在于解决冗余，这是动态规划算法的根本目的。动态规划实质上是一种以空间换时间的技术，它在实现的过程中，不得不存储产生过程中的各种状态，所以它的空间复杂度要大于其它的算法。

#### 导弹拦截问题

某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。

**问题形式化描述**

因为只有一套导弹拦截系统，并且这套系统除过第一发炮弹能到达任意高度外，以后的每一发炮弹都不能高于前一发炮弹的高度。所以，被拦截的导弹应该按照飞来的高度组成一个非增序列。计算这套系统最多能够拦截的导弹数，并依次输出被拦截导弹的高度，实际上就是要求在导弹依次飞来的高度序列中寻找一个最长的非递增子序列。

设X={x1,x2,...,xn}为依次飞来的导弹序列，Y={y1,y2,...,ym}是问题的最优解。不妨假设y1=x1（若不然则存在最小的下标k，使得xk=y1），则序列X1={x2,x3,...,xn}问题的最优解是Y1={y2,y3,...,ym}，这说明导弹拦截问题的最优子结构性质。

设d(i)为第i枚导弹被拦截后，这套系统最多还能拦截的导弹数量（包含被拦截的第i枚）。若xk是X序列中的最小值，d(xk)=1。d(xn)=1，最后一枚导弹也是1， 其它情况d>=1。

#### 主函数

```c++
/*导弹拦截问题
* X={x1,x2,...,xn}表示飞来的各导弹的高度
* d[i]记录第i枚导弹被拦截之后，这套系统最多还能拦截的导弹数量（包含被拦截的第i枚导弹）
* 若xk是X序列中的最小值，d(xk)=1
* d(xn)=1. 其它情况d>=1.
*/
#include<iostream>
using namespace std;
const int N = 10;// 最大导弹数量
int x[N], d[N];

int main()
{
	int i,j,n;
	int dmax = 0, xh = 0;//dmax:最多可以拦截的导弹数量，xh:第一枚拦截的导弹序号
	cout << "输入要拦截的导弹数量:" << endl;
	cin >> n;
	cout << "输入每个导弹的高度：" << endl;
	for (i = 0; i < n; i++)
	{
		cin >> x[i];
		d[i] = 1;
	}
	for (i = n - 2; i >= 0; i--)//动态规划算法，从后面向前搜索
	{
		for (j = i + 1; j < n; j++)//遍历当前节点后面的所有节点,在子序列中找最长子序列
			if (x[j] <= x[i] && d[i] < (d[j] + 1))
				d[i] = d[j] + 1;
	}
	//找出最长子序列的个数和第一枚拦截导弹的序号
	for (i = 0; i < n; i++)
	{
		if (dmax < d[i])
		{
			dmax = d[i];
			xh = i;
		}	
	}
	cout << "最多可以拦截的导弹数为：" << dmax << endl;
	cout << "被拦截的导弹高度依次是：";
	//依次输出最长序列
	cout << x[xh] << " ";
	int itemp = xh;
	for (i = xh+1; i < n;i++)
	{
		if ((x[i] <= x[itemp]) && (d[itemp] == d[i] + 1))
		{
			cout << x[i]<<" ";
			itemp = i;
		}
	}

	cout << endl;
	return 0;
}
```

首先确定飞来导弹的个数，比如输入是8，把每枚导弹的高度输入。程序运行结果如下图所示：

![二叉树](C:\Users\Administrator\Documents\Visual Studio 2013\Projects\动态规划算法（导弹拦截问题）\动态规划算法（导弹拦截问题）.JPG)

#### 参考：算法分析与设计(C++描述) 石志国、刘冀伟、姚亦飞编著